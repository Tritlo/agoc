<!DOCTYPE html>
<html>
<head>
  <meta charset="utf-8">
  <meta name="viewport" content="width=device-width, initial-scale=1.0">
  <title>AGoC</title>
  <link rel="icon" type="image/svg+xml" href="./favicon.svg">

  <!-- OpenGraph metadata -->
  <meta property="og:title" content="AGoC">
  <meta property="og:type" content="website">
  <meta property="og:image" content="./preview.png">
  <meta property="og:description" content="A demo showcasing running Haskell code compiled to WebAssembly using the GHC WASM backend. Functional programming in the browser with full access to JavaScript APIs through FFI.">
  <meta property="og:site_name" content="AGoC">
  <!-- Import map for ES modules -->
  <script type="importmap">
    {
      "imports": {
        "three": "./vendor/three@0.181.0/build/three.module.min.js"
      }
    }
  </script>

  <!-- Load PixiJS (vendored) -->
  <script src="./vendor/pixi.js@8.0.0/dist/pixi.min.js"></script>
  <script src="./vendor/d3/d3.min.js"></script>

  <style>
    * {
      margin: 0;
      padding: 0;
      box-sizing: border-box;
    }

    html, body {
      margin: 0;
      padding: 0;
      overflow: hidden;
      height: 100%;
      position: fixed;
      width: 100%;
      touch-action: none;
   }


    .container {
      width: 100vw;
      height: 100vh;
      margin: 0;
      padding: 0;
      background: black;
      border: none;
      box-shadow: none;
      overflow: hidden;
    }

  </style>
</head>
<body>
  <script type="module">
    import { WASI } from "./vendor/@runno/wasi@0.7.0/dist/wasi.js";
    import ghc_wasm_jsffi from "./ghc_wasm_jsffi.js";
    import * as THREE from 'three';

    // Make Three.js available globally for WASM FFI
    window.THREE = THREE;

    // Initialize Steamworks if available (Electron context)
    let steamworksReady = false;

    if (window.steamworks) {
      window.steamworks.isInitialized().then(async (initialized) => {
        steamworksReady = initialized;
        if (initialized) {
          console.log('Steamworks initialized');
          // Example: Get Steam user info
          window.steamworks.getPersonaName().then((name) => {
            console.log('Steam user:', name);
          });
        } else {
          console.log('Steamworks not available (Steam may not be running)');
        }
      });
    }

    // Enable gamepad API - required for Electron/Windows
    // Gamepads need to be activated through user interaction or event listeners
    window.addEventListener('gamepadconnected', (e) => {
      console.log('Gamepad connected:', e.gamepad.id);
    });

    window.addEventListener('gamepaddisconnected', (e) => {
      console.log('Gamepad disconnected:', e.gamepad.id);
    });

    // Poll gamepads periodically to ensure they're detected
    // This is especially important for Electron on Windows
    setInterval(() => {
      if (navigator.getGamepads) {
        navigator.getGamepads();
      }
    }, 100);

    // Make PIXI available globally for the WASM module
    window.PIXI = PIXI;
    const audio_context = new AudioContext();
    const master = audio_context.createGain();
    master.gain.value = 0.9;
    master.connect(audio_context.destination);


    window.blip = (freq = 440, ms = 80, vol = 0.2) => {
      const oscillator = audio_context.createOscillator();
      const gain = audio_context.createGain();
      oscillator.type = "square";
      oscillator.frequency.setValueAtTime(freq, audio_context.currentTime);

      const t0 = audio_context.currentTime;
      const attack = 0.002;
      const release = Math.max(0.01, ms / 1000 - attack);
      gain.gain.setValueAtTime(0, t0);
      gain.gain.linearRampToValueAtTime(vol, t0 + attack);
      gain.gain.exponentialRampToValueAtTime(0.0001, t0 + attack + release);

      oscillator.connect(gain).connect(master);
      oscillator.start(t0);
      oscillator.stop(t0 + attack + release + 0.02);
    }

    // Dice roll sound - 8-bit style bouncing dice
    // numDice: number of dice being rolled (more dice = more overlapping sounds)
    window.rollDice = (numDice = 1) => {
      const now = audio_context.currentTime;
      const rollDuration = 1.5; // Match dice animation duration

      // Scale volume to prevent clipping with many dice
      const volumeScale = 1 / Math.sqrt(Math.max(1, numDice));

      // Each die gets its own bounce sequence
      for (let d = 0; d < numDice; d++) {
        const dieOffset = d * 0.05 + Math.random() * 0.08; // Stagger dice starts
        const hits = 6 + Math.floor(Math.random() * 4); // 6-9 bounces per die
        let t = now + dieOffset;

        for (let i = 0; i < hits; i++) {
          const osc = audio_context.createOscillator();
          const gain = audio_context.createGain();

          osc.type = "square";
          // Higher pitch at start, lower as die settles
          osc.frequency.value = 150 + Math.random() * 200 + (hits - i) * 20;

          const startTime = t + Math.random() * 0.03;
          // Louder at start, quieter as die settles
          const peak = (0.08 + (hits - i) / hits * 0.12) * volumeScale;

          gain.gain.setValueAtTime(0.001, startTime);
          gain.gain.exponentialRampToValueAtTime(peak, startTime + 0.005);
          gain.gain.exponentialRampToValueAtTime(0.001, startTime + 0.04);

          osc.connect(gain).connect(master);
          osc.start(startTime);
          osc.stop(startTime + 0.05);

          // Bounces get closer together as die settles (like real physics)
          const progress = i / hits;
          const interval = rollDuration / hits * (1.5 - progress * 0.8);
          t += interval * (0.8 + Math.random() * 0.4);
        }
      }
    };

    // Check for WebAssembly support
    if ("WebAssembly" in window) {
      const wasi = new WASI({
        stdout: (out) => console.log("[wasm stdout]", out),
        stderr: (out) => console.error("[wasm stderr]", out)
      });

      const jsffiExports = {};

      try {
        console.log('Creating JSFFI imports...');
        const jsffiImports = ghc_wasm_jsffi(jsffiExports);
        console.log('JSFFI imports created:', jsffiImports);

        console.log('Getting WASI import object...');
        const wasiImports = wasi.getImportObject();
        console.log('WASI imports:', Object.keys(wasiImports));

        const importObject = Object.assign(
          { ghc_wasm_jsffi: jsffiImports },
          wasiImports
        );
        console.log('Full import object:', Object.keys(importObject));

        console.log('Fetching and instantiating WASM...');
        const result = await WebAssembly.instantiateStreaming(
          fetch('./agoc.wasm'),
          importObject
        );

        console.log('WASM instantiated, result:', result);
        console.log('Instance:', result.instance);

        if (!result || !result.instance) {
          throw new Error('Failed to get instance from instantiateStreaming');
        }

        const instance = result.instance;
        console.log('Instance exports:', Object.keys(instance.exports));

        // Fill in the jsffiExports with the instance exports for FFI to work
        Object.assign(jsffiExports, instance.exports);
        console.log('JSFFI exports filled:', Object.keys(jsffiExports));

        // Initialize the reactor module (instead of start)
        // wasi.initialize expects the full result object, not just the instance
        console.log('Initializing WASI...');
        wasi.initialize(result, {
          ghc_wasm_jsffi: ghc_wasm_jsffi(jsffiExports)
        });
        console.log('WASI initialized');

        // Call the exported main function
        if (instance.exports.main) {
          console.log('Calling main...');
          instance.exports.main();
        } else {
          console.log('No main export found in agoc.wasm.');
          console.log('Available exports:', Object.keys(instance.exports));
        }

      } catch (error) {
        console.error('Error loading WASM:', error);
        console.error('Error stack:', error.stack);
        const contentDiv = document.querySelector('.content');
        if (contentDiv) {
          contentDiv.innerHTML += `<div class="error">Error loading WASM: ${error.message}\n${error.stack}</div>`;
        }
      }
    } else {
      const contentDiv = document.querySelector('.content');
      if (contentDiv) {
        contentDiv.innerHTML += '<div class="error">This browser does not support WebAssembly.</div>';
      }
    }
  </script>
</body>
</html>
